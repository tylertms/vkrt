#version 460
#extension GL_EXT_ray_tracing : enable
#include "utility/bindings.glsl"

layout(location = 0) rayPayloadEXT Payload payload;

#include "utility/trace.glsl"

void main() {
    ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);
    ivec2 viewportOrigin = ivec2(scene.viewportRect.xy);
    ivec2 viewportSize = ivec2(scene.viewportRect.zw);

    if (viewportSize.x <= 0 || viewportSize.y <= 0) {
        imageStore(accumulationWriteImage, pixel, vec4(0.0));
        imageStore(outputImage, pixel, vec4(0.0));
        return;
    }

    ivec2 viewportMax = viewportOrigin + viewportSize;
    if (pixel.x < viewportOrigin.x || pixel.y < viewportOrigin.y || pixel.x >= viewportMax.x || pixel.y >= viewportMax.y) {
        imageStore(accumulationWriteImage, pixel, vec4(0.0));
        imageStore(outputImage, pixel, vec4(0.0));
        return;
    }

    uint spp = max(scene.samplesPerPixel, 1u);
    vec4 previous = imageLoad(accumulationReadImage, pixel);
    uint previousSamples = uint(previous.a + 0.5);
    uint rngBase = initRngBase(uvec2(pixel), scene.frameNumber);

    vec3 frameRadiance = vec3(0.0);
    for (uint sampleIndex = 0; sampleIndex < spp; sampleIndex++) {
        uint sampleNumber = previousSamples + sampleIndex;
        uint state = initRngState(rngBase, sampleNumber);
        frameRadiance += traceSample(pixel, state);
    }
    frameRadiance /= float(spp);

    float previousWeight = float(previousSamples);
    float newWeight = float(spp);
    vec3 accumulated = (previous.rgb * previousWeight + frameRadiance * newWeight) / (previousWeight + newWeight);

    vec3 mapped = accumulated;
    if (scene.toneMappingMode == 1u) {
        mapped = toneMapACES(mapped);
    }

    imageStore(accumulationWriteImage, pixel, vec4(accumulated, previousWeight + newWeight));
    imageStore(outputImage, pixel, vec4(mapped, 1.0));
}
